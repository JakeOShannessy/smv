\documentclass[11pt,twoside]{book}

%% include commands for bios, titles etc used in multiple documents
%%
\input{../Bibliography/commoncommands}
\IfFileExists{../Bibliography/gitrevision.tex}
{\input{../Bibliography/gitrevision}}
{\newcommand{\gitrevision}{unknown} }
% \usepackage{picins}
\usepackage{listings}
%% commands only used by this guide

\newcommand{\svini}{{\tt smokeview.ini}\ }
\newcommand{\infigheight}{0.85in}
\newcommand{\figheightAbar}{2.2in}
\newcommand{\figheightC}{2.5in}
\newcommand{\infigr}[2]{
\parpic[r]{
\begin{tabular}{c}
\includegraphics[height=\infigheight]{SCRIPT_FIGURES/#1}\\
{\small\tt #2}
\end{tabular}
}
}
\newcommand{\infigl}[2]{
\parpic[l]{
\begin{tabular}{c}
\includegraphics[height=\infigheight]{SCRIPT_FIGURES/#1}\\
{\small\tt #2}
\end{tabular}
}
}
\newcommand{\frameit}[1]{\fbox{\tt #1}}
\newcommand{\kitem}[1]{\item[{\bf {\tt #1 \  }} \hfill]}
\newcommand{\figheight}{1.5in}
\newcommand{\figheightA}{2.5in}
\newcommand{\figwidth}{3.333333in}
\newcommand{\figwidthb}{2.0in}
\newcommand{\parma}{.75}
\newcommand{\parmb}{.5}
\newcommand{\parmc}{0.25}
\newcommand{\blist}{
\begin{list}
{}{
\setlength{\leftmargin}{\parma in}
\setlength{\labelwidth}{\parmb in}
\setlength{\labelsep}{\parmc in}
\setlength{\listparindent}{0.3in}
\setlength{\topsep}{.3in}
\setlength{\parsep}{.0in}
}}
\newcommand{\elist}{\end{list}}
\newcommand{\loadmenu}{\fbox{\ct Load/Unload}}
\newcommand{\hitem}[1]{\item[{\bf #1} \hfill]}
\newcommand{\hitemNULL}[1]{}
\newcommand{\hhitem}[2]{\item[{\bf #1}\ ({\em #2}) \hfill]}

\lstdefinestyle{lua}
{
  language         = {[5.2]Lua},
  upquote          = true,
  basicstyle=\scriptsize,
  aboveskip={1.5\baselineskip},
  columns=fixed,
  showstringspaces=false,
  extendedchars=true,
  breaklines=true,
  prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
  frame=single,
  showtabs=false,
  showspaces=false,
  showstringspaces=false,
  identifierstyle=\ttfamily,
  keywordstyle=\color[rgb]{0,0,1},
  commentstyle=\color[rgb]{0.133,0.545,0.133},
  stringstyle=\color[rgb]{0.627,0.126,0.941},
}

%\doublespace
\begin{document}

\bibliographystyle{unsrt}
\pagestyle{empty}

%
% ----------------------  first cover/title page --------------------------
%
\begin{minipage}[t][9in][s]{6.5in}

% \headerA{1017-1\\Sixth Edition\\}


\vspace{1in}

\headerB{
Smokeview, A Tool for Visualizing\\
Fire Dynamics Simulation Data\\
Lua Scripting Guide\\
}

\vspace{.5in}
\headerC{Jake O'Shannessy}

\vfill

\begin{flushright}
% \includegraphics[width=2.in]{FIGURES/nistident_flright_vec}
\end{flushright}
\end{minipage}

\newpage

\hspace{5in}
\newpage

%
% ----------------------  second cover/title page --------------------------
%
\begin{minipage}[t][9in][s]{6.5in}

% \headerA{1017-1\\Sixth Edition}

\vspace{1.in}

\headerB{
Smokeview, A Tool for Visualizing\\
Fire Dynamics Simulation Data\\
Lua Scripting Guide\\
}

\vspace{.5in}

\headerC{Jake O'Shannessy\\
% {\em Fire Research Division} \\
% {\em Engineering Laboratory}  \\
}

\vspace{.25in}


%\flushright{\today \\
\begin{flushright}
\today \\
Smokeview Version \smvversion \\
\emph{Git Revision:}~\gitrevision
\end{flushright}
%
\vfill

\begin{flushright}
% \includegraphics[width=1in]{FIGURES/doc}
\end{flushright}

% \titlesigs

\end{minipage}


\date{}

\setlength{\parindent}{0.25in}

\newpage

\begin{minipage}[t][9in][s]{6.5in}


\begin{flushright}
% Certain commercial entities, equipment, or materials may be identified in this \\
% document in order to describe an experimental procedure or concept adequately. Such \\
% identification is not intended to imply recommendation or endorsement by the \\
% National Institute of Standards and Technology, nor is it intended to imply that the \\
% entities, materials, or equipment are necessarily the best available for the purpose.
\end{flushright}

\vspace{3in}


\vspace{3in}

\large
\begin{flushright}
% \bf National Institute of Standards and Technology Special Publication 1017-1 \\
% Natl.~Inst.~Stand.~Technol.~Spec.~Publ.~1017-1, \pageref{LastPage} pages (June 2016) \\
% CODEN: NSPUE2
\end{flushright}

\vfill

\end{minipage}


\frontmatter

\pagestyle{plain}

%---------------------------------------------------------------------------------
%------------------------ Preface ------------------------------------------------
%---------------------------------------------------------------------------------

\chapter{Preface}
\smvoverview
This guide covers the embedded lua scripting engine in Smokeview.

%---------------------------------------------------------------------------------
%------------------------ About the Author ---------------------------------------
%---------------------------------------------------------------------------------

% \chapter{About the Author}

% \begin{description}
% \gforneybio
% \end{description}

%---------------------------------------------------------------------------------
%------------------------ Disclaimer ---------------------------------------------
%---------------------------------------------------------------------------------

% \chapter{Disclaimer}

% The US Department of Commerce makes no warranty,
% expressed or implied, to users of Smokeview, and accepts no
% responsibility for its use. Users of Smokeview assume sole
% responsibility under Federal law for determining the
% appropriateness of its use in any particular application; for any
% conclusions drawn from the results of its use; and for any actions
% taken or not taken as a result of analysis performed using this
% tools.

% Smokeview and the companion program FDS is intended for use only
% by those competent in the fields of fluid dynamics,
% thermodynamics, combustion, and heat transfer, and is intended
% only to supplement the informed judgment of the qualified user.
% These software packages may or may not have predictive capability
% when applied to a specific set of factual circumstances. Lack of
% accurate predictions could lead to erroneous conclusions with
% regard to fire safety. All results should be evaluated by an
% informed user.

% Throughout this document, the mention of computer hardware or
% commercial software does not constitute endorsement by NIST,
% nor does
% it indicate that the products are necessarily those
% best suited for the
% intended purpose.

%---------------------------------------------------------------------------------
%------------------------ Acknowledgements ---------------------------------
%---------------------------------------------------------------------------------

% \chapter*{Acknowledgements}
% A number of people have made significant contributions to the
% development of Smokeview. In trying to acknowledge those that have
% contributed, we are inevitably going to miss a few people.  Let us
% know and we will include those missed in the next version of this
% guide.

% The original version of Smokeview was inspired by Frames, a
% visualization program written by James Sims for the Silicon
% Graphics workstation.  This software was based on visualization
% software written by Stuart Cramer for an Evans and Sutherland
% computer. Frames used tracer particles to visualize smoke flow
% computed by a pre-cursor to FDS. Judy Devaney made the
% multi-screen eight foot Rave facility available allowing a stereo
% version of Smokeview to be built that can display scenes in
% 3D.  Both Steve Satterfield and Tere Griffin on many occasions
% helped me demonstrate Smokeview cases on the Rave inspiring many
% people to the possibility of using Smokeview as a {\em virtual
% reality-like}\ fire fighter training facility.

% Many conversations with Nelson Bryner, Dave Evans, Anthony Hamins
% and Doug Walton were most helpful in determining how Smokeview
% could be adapted for use in fire fighter training applications.

% Smokeview would not be possible without the use of a number of
% software libraries developed by others.  Mark Kilgard while at
% Silicon Graphics developed GLUT, the basic tool kit for
% interfacing OpenGL with the underlying operating system on
% multiple computer platforms. Paul Rademacher while a graduate
% student at the University of North Carolina developed GLUI, the
% software library for implementing the user friendly dialog boxes.

% Significant contributions have been made by those that have used
% Smokeview to visualize complex cases; cases that are used to
% perform both applied and basic research.  The resulting feedback
% has improved Smokeview as a result of their interaction with me,
% pushing the envelope and not accepting the status quo.

% For applied research, Daniel Madrzykowski, Doug Walton and Robert
% Vettori of NIST have used Smokeview to analyze fire incidents.
% Steve Kerber has used Smokeview to visualize flows resulting from
% positive pressure ventilation (PPV) fans. David Stroup has used
% Smokeview to analyze cases for use in fire fighter training
% scenarios.  Conversations with Doug Walton have been particularly
% helpful in identifying needed features and clarifying how best to
% make their implementation user friendly.  David Evans, William
% (Ruddy) Mell and Ronald Rehm used Smokeview to visualize {\em
% wildland-urban interface}\ fires.   For basic research, Greg
% Linteris has used Smokeview to visualize fire simulations
% involving the cone calorimeter. Anthony Hamins has used Smokeview
% to visualize the structure of CH$_4$/air flames undergoing the
% transition from normal to microgravity conditions and fire
% suppression in a compartment. Jiann Yang has used Smokeview to
% visualize smoke or particle number density and saturation ratio of
% condensable vapor.

% This user's guide has improved through the many constructive
% comments of the reviewers Anthony Hamins, Doug Walton, Ronald
% Rehm, and David Sheppard. Chuck Bouldin helped port Smokeview to
% the Macintosh.

% Many people have sent in multiple comments and feedback by email,
% in particular Adrian Brown, Scot Deal, Charlie Fleischmann, Jason
% Floyd, Simo Hostikka, Bryan Klein, Davy Leroy, Dave McGill, Brian
% McLaughlin, Derek Nolan, Steven Olenick, Stephen Priddy, Boris
% Stock, Jason Sutula, Javier Trelles, and Christopher Wood.

% Feedback is encouraged and may be sent to glenn.forney@nist.gov .

\cleardoublepage
\tableofcontents

\cleardoublepage
\listoffigures

\cleardoublepage
\listoftables

\mainmatter

\pagenumbering{arabic}

%---------------------------------------------------------------------------------
%------------------------ Introduction ----------------------------------------
%---------------------------------------------------------------------------------

\part{Using the Lua Engine}
\chapter{Introduction}
\section{Overview}
There are two scripting engines within Smokeview that allow it to be
programmatically controlled. This allows for analysis such as rendering of
visualisations and post-processing to be performed automatically and
reproducibly. This guide does not cover the functionality of Smokeview itself,
only how to access that functionalilty programmatically, as well as any
additional features provided by the lua engine.

The lua engine is designed to post-process all data produced by FDS (and also
CFAST) and is not limited to what is visually represented by Smokeview.

As all configuration options are exposed via the lua API, it is also possible to
use lua as a configuration file format.

% TODO: explain in a similar manner the use of .lua scripts.
% \begin{figure}[bph]
% \centerline{
% \includegraphics[width=6.5in]{FIGURES/SMV_Overview_Diagram}}
%  \caption[FDS file overview]{Diagram illustrating files used and created by the Fire Dynamics
%  Simulator (FDS), Smokezip and Smokeview.}
% \label{figfdsoverview}%
% \end{figure}

\section{Features}

Smokeview is a program designed to visualize numerical
calculations generated by the Fire Dynamics Simulator.
The version of FDS used to run the cases illustrated  in this report
is given by:
% \lstinputlisting{SCRIPT_FIGURES/fds.version}
The version of Smokeview described here and used
to generate most figures in this report is given by:
% \lstinputlisting{SCRIPT_FIGURES/smokeview.version}

\section{Controlling the Window and View}

Window specific control is done via the \verb|window| table. To set the size
of the window use the \lstinline{window.size(width,height)} command.

The rest of the view control is done via the \lstinline{view} table. This
doesn't control any of the content of the model or data being viewed, but
modifies the annotation content of the window, such as colour bars, labels,
notes, etc.

\subsection{Time Frames}

The currently viewed frame of whatever data is loaded is governed via the view
table. The frame can be chosen by setting the \lstinline{view.frame} value to a
specified frame index (starting from 0). If a certain time is desired the
\lstinline{view.settime(time)} function can be used. This is a function rather
than a value to be set, as this function will find the frame closest to that
time and set \lstinline{view.frame} to that. Information on frames can be found
via the \lstinline{global_times} global array object, which is an array of all
the time values for each frame. Unlike normal lua arrays this is indexed from 0
to match the frame indices used in Smokeview. For instance, you can loop through
each frame using the following \lstinline{for..in} loop:

\begin{lstlisting}[style=lua]
for i,time in ipairs(global_times) do
    view.frame = i
    render("Render at - \%.0fs(\%.0fs)", time, gettime())
end
\end{lstlisting}

The render line can be ignored for, as it will be introduced later, except that
it also introduces the gettime() function, which gets the time value of the
current frame. This is a useful function as the actual time of the frame being
viewed may not match the time requested when using the
\lstinline{view.settime(time)} function.

\subsection{Colourbar}

The colourbar is controlled using the \lstinline{view.colorbar} table. The colorbar table includes the following options:

\lstinline{flip}: A boolean value to determine if the colorbar is flipped. Can be set or
read.

\begin{lstlisting}[style=lua]
-- Set the colorbar as flipped.
view.colorbar.flip = true
if view.colobar.flip
    then print("The colorbar is flipped.")
    else print("The colorbar is not flipped.")
end
\end{lstlisting}

%texture_flag: a function which sets the texture flag

\lstinline{index}: An integer value which determines the value of the contour in the
colourbar. When set to nil there is no contour. The integer value is from 0-255.
Can be set or read. If a particular contour value (with respect to the units
shown) is required, the \lstinline{bounds} information can be used to calculate
an appropriate index value.

\begin{lstlisting}[style=lua]
-- Set the contour to the middle of the colorbar.
view.colorbar.index = 255
-- Render an image.
render()
-- Remove the contour from the colorbar.
view.colorbar.index = nil
\end{lstlisting}

\lstinline{show}: A boolean value which determines if the colorbar is shown. Can be set or
read.

\lstinline{colors}: A table of colours used in the colorbar. Can be set or read. WARNING:
liable to signifcant changes.

\subsection{Clipping}

The clipping properties are quite commonly required when rendering different
views of data. These are all accesssed directly using the \lstinline{clipping}
table. The options in this table consist entirely of setting and unsetting the
clipping values for the three axes and selecting a clipping mode.

Setting the clipping type is done via the \lstinline{clipping.mode} value, which
is an integer of 4 different values:

\begin{itemize}
\item 0: No clipping.
\item 1: Clip blockages and data.
\item 2: Clip blockages.
\item 3: Clip data.
\end{itemize}

Setting the clipping dimensions can be done a number of ways. The recommended
way is to treat the clipping object as a value, keeping in mind that
\lstinline{nil} means that clipping for that value is turned off.

\begin{lstlisting}[style=lua]
-- Turn off all clipping values.
clipping = nil
-- Set the maximum z clipping plane to 2.0 m.
clipping.z.max = 2
-- Set the minimum x clipping plane to -5 m
clipping.x.min = -5
-- Turn off clipping on the z axis
clipping.z = nil
\end{lstlisting}

\subsection{Camera Control}

The camera is set and get using \lstinline{camera.set(camera)} and
\lstinline{camera.get} respectively. This is done using camera objects (tables)
which contain all of the camera information.

A camera table is as follows:

\begin{lstlisting}[style=lua]
local topDown = {
    rotationType = 0,
    eyePos = { x = 0.502333, y = -2.405097, z = 0.396825},
    zoom =  1.0,
    viewAngle = 0,
    directionAngle = 0,
    elevationAngle = 0,
    projectionType = 1,
    viewDir  = {x =  0.500000, y = 0.192460, z = 0.396825},
    zAngle = {az = 0.000000, elev = 90.000000},
    transformMatrix = nil,
    clipping = nil
}
\end{lstlisting}

This camera can now be used to set the view in viewport via:

\begin{lstlisting}[style=lua]
-- TODO: this should be camera = topDown
camera.set(topDown)
\end{lstlisting}

Note that the various cameras are not managed internally by the Smokeview camera
mechanism when using this technique, and are just stored as lua variables
containing the data necessary to set up the cameras.

\subsection{Colour}

The \lstinline{view.color} table includes a number of options governing colour
and lighting in the view space. The options are as follows:

\begin{itemize}
\item \lstinline{ambientlight(r,g,b)}: Set the ambient light value.

\item \lstinline{backgroundcolor(r,g,b)}: Set the background colour.

\item \lstinline{blockcolor(r,g,b)}: Set the block colour.

\item \lstinline{blockshininess(v)}: Set the blockshininess value.

\item \lstinline{blockspecular(r,g,b)}: Set the block specular colour.

\item \lstinline{boundcolor(r,g,b)}: Set the bound colour.

\item \lstinline{diffuselight(r,g,b)}: Set the diffuse light colour.
\end{itemize}
\subsection{Miscellaneous View Options}

There are a large number of view options in Smokeview, most of which are
included in the \lstinline{view} table. All view options that can be controlled
via the menus or \verb|.ini| config files are available. Here a few of the more
common options:

\section{Data Loading}

%We should consider have a data table instead of a load table. This would make
%more sense when listing loaded data and unloading.
In order to view anything useful in Smokeview data (such as slice files) must be
loaded. This is typically done view teh \lstinline{load} table, which contains
various functions for loading and unloading data. The only exception is the
unloading function, which can be called as \lstinline{unload.all()}. This is
simply a synonym for \lstinline{load.unload.all()}.

Loading can be a surprisingly complex topic in Smokeview, and for this reason the lua engine exposes the data loading API down to the lowest practical level, which is the loading of a single data file. All data files (with the exception of CSV files) in Smokeview are per-mesh. This means that, for example, when loading slice files you will likely want to load multiple files across different meshes in a simulation. As there is nothing strictly linking various slice files together there are multiple logical ways to load groups of slice files.

To allow for maximum flexibility, the lower level API only exposes two
functions: \lstinline{load.datafile(filename)} and
\lstinline{load.datafile(filename)} (for non-vector and vector files
respectively). All other loading functions are simply convinience functions to
help users determine which files should be loaded. For example:
\lstinline{load.namedslice(name)} finds all instances of a slice that were given
a certain name and loads them using \lstinline{load.datafile}. If you included a slice in your FDS code of:

\begin{lstlisting}[style=lua]
&SLCF ID='tempx' QUANTITY='TEMPERATURE' PBX=1.3 /
\end{lstlisting}

Then you could load this value across all meshes using the script:

\begin{lstlisting}[style=lua]
load.namedslice("tempx")
\end{lstlisting}

This is particularly useful when loading slices that span meshes of different
resolutions. For example if the x cell width of some of the simulations was
0.2~m, it might be that some of the slice is at x = 1.3~m and some of the slice
is at x = 1.4~m, in which case the id of the slice is the only thing linking the
various data files.

In other cases the \lstinline{load.slice(matchFunc)} function is useful, where
matchFunc is a function which takes the slice information as an argument and
returns a boolean which determines whether to load each data file or not.

3D Smoke files (including HRRPUV) can be loaded using
\lstinline{load3dsmoke(type)}, where \lstinline{type} is something like
\lstinline{SOOT MASS FRACTION} or \lstinline{HRRPUV}.

\section{Rendering and Output}

The basic rendering command is the \lstinline[style=lua]{render()} function,
which renders the current frame. Without an argument this simply uses the
default Smokeview rendering style, rendering into the specified render
directory. If the argument is a string, then that string is used as the base for
the filename (the extension is added). If the argument is a function, then that
function is called at render time and is expected to return the string that will
be used as the filename.

\begin{lstlisting}[style=lua]
-- Render as if 'r' was pressed in Smokeview.
render()
-- Render to '$RENDERDIR/testimage.png'
render('testimage')
-- Render to to a file with the time appended.
render(function() return string.format("test image at %.2f s", gettime()) end)
\end{lstlisting}

The directory to which Smokeview renders images can also be retrieved or
modified via the \lstinline{render.dir} variable.

\begin{lstlisting}[style=lua]
-- Print the current render directory to stdout.
print(render.dir)
-- Change the render directory to "images".
render.dir = "images"
\end{lstlisting}

\section{Accessing Information}

Most of the information available to Smokeview is exposed in read-only
variables.

The CHID of the currently loaded simulation is stored in \lstinline{chid}.

Information on the meshes is stored in the \lstinline{meshinfo} table. Indices
in this table match the MESH indices (i.e. from 1). For example, if we want to
look at the what meshes we have in our mesh we could use the following script:

\begin{lstlisting}[style=lua]
    print(string.format("CHID: %s", chid))
    print(string.format("----------------------------------------------------------------"))
    print(string.format("#\t|\tMeshId.\t|\t# Cells\t|\tI-J-K"))
    print(string.format("----------------------------------------------------------------"))
    local totalCells = 0
    for k,mesh in ipairs(meshinfo) do
        local nCells = mesh.ibar * mesh.jbar * mesh.kbar
        totalCells = totalCells + nCells
        print(string.format("%d\t|\t%s\t|\t%d\t|\t%d-%d-%d", k, mesh.label, nCells,
                            mesh.ibar, mesh.jbar, mesh.kbar))
    end
    print(string.format("----------------------------------------------------------------"))
    print(string.format("Total\t|\t    \t|\t%d\t|", totalCells))
    print(string.format("----------------------------------------------------------------"))
    exit()
\end{lstlisting}

An example result of this script might be:

\begin{lstlisting}
    CHID: ExampleModel
    ----------------------------------------------------------------
    #       |       MeshId. |       # Cells |       I-J-K
    ----------------------------------------------------------------
    1       |       Mesh02  |       275808  |       102-52-52
    2       |       Mesh03  |       102752  |       38-52-52
    3       |       Mesh04  |       65520   |       63-40-26
    4       |       Mesh05  |       70434   |       63-43-26
    5       |       Mesh06  |       75166   |       49-59-26
    6       |       Mesh07  |       308672  |       106-56-52
    7       |       Mesh08  |       110656  |       38-56-52
    ----------------------------------------------------------------
    Total   |               |       1009008 |
    ----------------------------------------------------------------
\end{lstlisting}

Information on slices is stored in the \lstinline{sliceinfo} table, and the
operation is similar.

\section{Accessing and Post-Processing Data}

All of the functionality thus far has covered manipulating Smokeview to produce
various visualisations as you would do manually. This has a lot of benefit in
automating repetive tasks and provided reproducibility, but only covers what is
already possible via Smokeview manually. There is a lot of other work that is
done using the results of FDS simulations that is done outside of Smokeview, but
as our lua engine has access to all of the data produced by FDS and seen by
Smokeview, it makes sense to utilise it for other post-processing tasks as well.

A very simple but common task is to produce a plot showing the HRR of a
particular simulation over time. This kind of plot can be easily obtained from
Excel or similar data processing tools, but as we are scripting Smokeview to
handle the results of our simulations already, let's do the same for the HRR
plot. This could be handled as follows:

\begin{lstlisting}[style=lua]
require("plot")
local hrrDV = csvinfo['hrr'].vectors['HRR']
plotDV(plotDir, hrrDV, "HRR")
\end{lstlisting}

This code accesses the CHID\_hrr.csv file (the \lstinline{csvinfo['hrr']} part)
and takes the 'HRR' vector from that file (the \lstinline{.vectors['HRR']}
part), and then plots it using the funciton plotDV. The CSV API assumes that the
first vector of every CSV file is the 'x' vector, which for FDS is usualy Time.

The plotDV funciton is not currently included by default with Smokeview in order
to not push a particular plotting library, but as the lua engine executes a full
programming language, any plotting software can be called, with the lua engine
providing the relevant data.

As full programming engine all kinds of other post processing can occur.

\end{document}
